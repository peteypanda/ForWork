This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-22T05:56:51.393Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.dockerignore
.gitignore
docker-compose.yml
Dockerfile
eslint.config.mjs
next.config.js
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
server.js
src/app/globals.css
src/app/layout.tsx
src/app/page.tsx
src/app/viewer/page.tsx
src/components/ControlUI.tsx
src/components/ViewerUI.tsx
src/hooks/useSocket.ts
tailwind.config.ts
tsconfig.json

================================================================
Files
================================================================

================
File: .dockerignore
================
.git
.gitignore
node_modules
npm-debug.log
README.md
.next
.env*
.dockerignore
Dockerfile
docker-compose.yml

================
File: .gitignore
================
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: docker-compose.yml
================
version: '3'

services:
  screenshare:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    restart: unless-stopped
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next

================
File: Dockerfile
================
# Use Node.js LTS
FROM node:20-alpine

# Create app directory
WORKDIR /app

# Install dependencies first (better caching)
COPY package*.json ./
RUN npm install

# Copy app source
COPY . .

# Build the app
ENV NODE_ENV=production

# Expose the port
EXPOSE 3000

# Start the server
CMD ["npm", "run", "dev"]

================
File: eslint.config.mjs
================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  webpack: (config) => {
    return config;
  }
};

module.exports = nextConfig;

================
File: package.json
================
{
  "name": "screenshare",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "NODE_ENV=production node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "next": "14.0.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "socket.io": "^4.7.2",
    "socket.io-client": "^4.7.2"
  },
  "devDependencies": {
    "@types/node": "^20.9.0",
    "@types/react": "^18.2.37",
    "@types/react-dom": "^18.2.15",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.53.0",
    "eslint-config-next": "14.0.3",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "typescript": "^5.2.2"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/vercel.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: server.js
================
const express = require('express');
const http = require('http');
const { Server } = require("socket.io");
const next = require('next');

const dev = process.env.NODE_ENV !== 'production';
const nextApp = next({ dev });
const nextHandler = nextApp.getRequestHandler();

// Track active connections
const activeRooms = new Map();

nextApp.prepare().then(() => {
  const app = express();
  const server = http.createServer(app);
  const io = new Server(server, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"]
    },
    path: "/socket.io/",
    serveClient: false,
    pingInterval: 10000,
    pingTimeout: 5000,
    cookie: false,
    connectTimeout: 45000,
    maxHttpBufferSize: 1e8,
    transports: ['websocket', 'polling'],
    allowUpgrades: true,
  });

  io.on('connection', (socket) => {
    console.log('A user connected:', socket.id);

    socket.on('join-room', async (room) => {
      console.log(`Socket ${socket.id} joining room: ${room}`);
      
      // Leave all other rooms first
      const currentRooms = Array.from(socket.rooms);
      for (const currentRoom of currentRooms) {
        if (currentRoom !== socket.id) {
          await socket.leave(currentRoom);
        }
      }
      
      // Join new room
      await socket.join(room);
      
      if (!activeRooms.has(room)) {
        activeRooms.set(room, new Set());
      }
      activeRooms.get(room).add(socket.id);

      console.log(`Room ${room} users:`, Array.from(activeRooms.get(room)));
    });

    socket.on('signal', (data) => {
      console.log(`Signal from ${socket.id} to ${data.screenName}:`, data.type);
      
      if (data.screenName) {
        socket.to(data.screenName).emit('signal', {
          ...data,
          from: socket.id
        });
      }
    });

    socket.on('stop-screenshare', (data) => {
      console.log(`Stop screenshare from ${socket.id} to ${data.screenName}`);
      if (data.screenName) {
        io.to(data.screenName).emit('stop-screenshare', {
          from: socket.id
        });
      }
    });

    socket.on('disconnect', () => {
      console.log('User disconnected:', socket.id);
      
      for (const [room, users] of activeRooms.entries()) {
        if (users.has(socket.id)) {
          users.delete(socket.id);
          if (users.size === 0) {
            activeRooms.delete(room);
          }
        }
      }
    });
  });

  app.all('*', (req, res) => {
    return nextHandler(req, res);
  });

  const PORT = process.env.PORT || 3000;
  server.listen(PORT, (err) => {
    if (err) throw err;
    console.log(`> Ready on http://localhost:${PORT}`);
  });
});

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

================
File: src/app/layout.tsx
================
import "./globals.css";
import type { Metadata } from "next";
import { Inter } from "next/font/google";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Screenshare",
  description: "Screen sharing application",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}

================
File: src/app/page.tsx
================
import ControlUI from "@/components/ControlUI";

export default function Home() {
  return (
    <main>
      <ControlUI />
    </main>
  );
}

================
File: src/app/viewer/page.tsx
================
import ViewerUI from "@/components/ViewerUI";

export default function ViewerPage() {
  return (
    <main>
      <ViewerUI />
    </main>
  );
}

================
File: src/components/ControlUI.tsx
================
"use client";

import React, { useState, useRef, useEffect } from 'react';
import { useSocket } from '@/hooks/useSocket';

const screens = [
  { id: 'pid1', name: 'PID 1' },
  { id: 'pid2', name: 'PID 2' },
  { id: 'pid3', name: 'PID 3' },
  { id: 'pid4', name: 'PID 4' },
  { id: 'outbound', name: 'Outbound Dock' },
  { id: 'dockclerk', name: 'Dock Clerk' },
];

export default function ControlUI() {
  const [isSharing, setIsSharing] = useState(false);
  const [selectedScreen, setSelectedScreen] = useState<string | null>(null);
  const [isSelectingScreen, setIsSelectingScreen] = useState(false);
  const [screenshot, setScreenshot] = useState<File | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [debugInfo, setDebugInfo] = useState<string[]>([]);
  
  const videoRef = useRef<HTMLVideoElement>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const peerConnection = useRef<RTCPeerConnection | null>(null);
  const socket = useSocket();

  const addDebugMessage = (message: string) => {
    console.log(message);
    setDebugInfo(prev => [...prev, `${new Date().toISOString()}: ${message}`]);
  };

  useEffect(() => {
    if (!socket) {
      addDebugMessage('Waiting for socket connection...');
      return;
    }

    const handleSignal = async (data: any) => {
      if (!peerConnection.current) return;

      try {
        if (data.type === 'answer') {
          addDebugMessage('Received answer');
          await peerConnection.current.setRemoteDescription(new RTCSessionDescription(data.answer));
        } else if (data.type === 'candidate' && data.candidate) {
          addDebugMessage('Received ICE candidate');
          await peerConnection.current.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      } catch (error) {
        console.error('Error handling signal:', error);
        addDebugMessage(`Signal error: ${error}`);
        setError('Failed to establish connection');
      }
    };

    socket.on('signal', handleSignal);

    return () => {
      socket.off('signal', handleSignal);
      stopSharing();
    };
  }, [socket]);

  const initializePeerConnection = () => {
    addDebugMessage('Initializing peer connection');
    
    peerConnection.current = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' },
      ],
      iceCandidatePoolSize: 10
    });

    if (!peerConnection.current || !socket || !selectedScreen) return;

    peerConnection.current.onicecandidate = (event) => {
      if (event.candidate) {
        addDebugMessage('Sending ICE candidate');
        socket.emit('signal', {
          type: 'candidate',
          candidate: event.candidate,
          screenName: selectedScreen
        });
      }
    };

    peerConnection.current.onconnectionstatechange = () => {
      const state = peerConnection.current?.connectionState;
      addDebugMessage(`Connection state changed to: ${state}`);
      
      if (state === 'failed') {
        setError('Connection failed. Attempting to reconnect...');
        setTimeout(() => {
          if (isSharing) {
            addDebugMessage('Attempting to reconnect...');
            confirmSharing();
          }
        }, 2000);
      }
    };

    peerConnection.current.oniceconnectionstatechange = () => {
      const state = peerConnection.current?.iceConnectionState;
      addDebugMessage(`ICE connection state: ${state}`);
      
      if (state === 'failed') {
        peerConnection.current?.restartIce();
      }
    };
  };

  const startSharing = async () => {
    setError(null);
    setDebugInfo([]);
    setIsSelectingScreen(true);
  };

  const confirmSharing = async () => {
    if (!selectedScreen || !socket) {
      setError('Please select a screen to share');
      return;
    }

    addDebugMessage(`Starting share process for screen: ${selectedScreen}`);
    socket.emit('join-room', selectedScreen);

    try {
      let stream: MediaStream;

      if (screenshot) {
        const img = new Image();
        img.src = URL.createObjectURL(screenshot);
        await new Promise((resolve) => (img.onload = resolve));
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx?.drawImage(img, 0, 0);
        stream = canvas.captureStream();
        addDebugMessage('Created stream from screenshot');
      } else {
        stream = await navigator.mediaDevices.getDisplayMedia({ 
          video: { 
            cursor: 'always',
            displaySurface: 'monitor'
          } 
        });
        addDebugMessage('Got display media stream');
      }

      streamRef.current = stream;
      initializePeerConnection();

      if (!peerConnection.current) {
        throw new Error('Failed to initialize peer connection');
      }

      stream.getTracks().forEach(track => {
        if (peerConnection.current && streamRef.current) {
          peerConnection.current.addTrack(track, streamRef.current);
        }
      });
      addDebugMessage('Added tracks to peer connection');

      const offer = await peerConnection.current.createOffer();
      await peerConnection.current.setLocalDescription(offer);
      addDebugMessage('Created and set local description');

      socket.emit('signal', {
        type: 'offer',
        offer,
        screenName: selectedScreen
      });
      addDebugMessage('Sent offer');

      if (videoRef.current) {
        videoRef.current.srcObject = stream;
      }

      setIsSharing(true);
      setIsSelectingScreen(false);

      stream.getVideoTracks()[0].onended = () => {
        addDebugMessage('Stream ended by user');
        stopSharing();
      };
    } catch (error) {
      console.error('Error starting screen share:', error);
      addDebugMessage(`Error: ${error}`);
      setError('Failed to start screen sharing');
      setIsSelectingScreen(false);
    }
  };

  const stopSharing = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }

    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }

    if (peerConnection.current) {
      peerConnection.current.close();
      peerConnection.current = null;
    }

    if (socket && selectedScreen) {
      socket.emit('stop-screenshare', { screenName: selectedScreen });
      addDebugMessage('Sent stop-screenshare signal');
    }

    setIsSharing(false);
    setSelectedScreen(null);
    setScreenshot(null);
    setError(null);
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-4">
      <h1 className="text-2xl font-bold mb-6">Screen Sharing Control</h1>
      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}
      <div className="space-y-6 w-full max-w-md">
        <div className="flex space-x-4">
          <button
            onClick={startSharing}
            disabled={isSharing}
            className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
          >
            Start Sharing
          </button>
          <button
            onClick={stopSharing}
            disabled={!isSharing}
            className="flex-1 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50"
          >
            Stop Sharing
          </button>
        </div>
        <div className="space-y-2">
          <label htmlFor="screenshot-upload" className="block text-sm font-medium text-gray-700">
            Upload Screenshot
          </label>
          <input
            id="screenshot-upload"
            type="file"
            onChange={(e) => {
              const file = e.target.files?.[0];
              if (file) setScreenshot(file);
            }}
            accept="image/*"
            disabled={isSharing}
            className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
          />
        </div>
      </div>
      <div className="mt-6 w-full max-w-2xl">
        <video 
          ref={videoRef} 
          autoPlay 
          playsInline 
          muted 
          className="w-full border border-gray-300 rounded-lg"
        />
      </div>
      {isSharing && selectedScreen && (
        <div className="mt-4 text-center">
          <p className="text-green-600 font-semibold">
            Currently sharing to: {screens.find((s) => s.id === selectedScreen)?.name}
            {screenshot ? " (Screenshot)" : ""}
          </p>
          <p className="text-sm text-gray-600 mt-2">
            Viewer URL: {`${window.location.origin}/viewer?screen=${selectedScreen}`}
          </p>
        </div>
      )}

      {isSelectingScreen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg p-6 max-w-md w-full">
            <h2 className="text-lg font-semibold mb-4">Select Screen to Share To</h2>
            <select
              value={selectedScreen || ''}
              onChange={(e) => setSelectedScreen(e.target.value)}
              className="w-full mb-4 p-2 border rounded"
            >
              <option value="">Choose a screen</option>
              {screens.map((screen) => (
                <option key={screen.id} value={screen.id}>
                  {screen.name}
                </option>
              ))}
            </select>
            <div className="flex justify-end space-x-2">
              <button
                onClick={() => setIsSelectingScreen(false)}
                className="px-4 py-2 border rounded hover:bg-gray-100"
              >
                Cancel
              </button>
              <button
                onClick={confirmSharing}
                disabled={!selectedScreen}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
              >
                Confirm
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Debug information */}
      <div className="fixed bottom-0 left-0 right-0 bg-black bg-opacity-75 text-white p-4 max-h-48 overflow-auto">
        <h3 className="font-bold mb-2">Debug Info:</h3>
        {debugInfo.map((msg, i) => (
          <div key={i} className="text-sm">{msg}</div>
        ))}
      </div>
    </div>
  );
}

================
File: src/components/ViewerUI.tsx
================
"use client";

import React, { useEffect, useRef, useState } from 'react';
import { useSocket } from '@/hooks/useSocket';

export default function ViewerUI() {
  const [isConnected, setIsConnected] = useState(false);
  const [debugInfo, setDebugInfo] = useState<string[]>([]);
  const videoRef = useRef<HTMLVideoElement>(null);
  const peerConnection = useRef<RTCPeerConnection | null>(null);
  const socket = useSocket();

  const addDebugMessage = (message: string) => {
    console.log(message);
    setDebugInfo(prev => [...prev, `${new Date().toISOString()}: ${message}`]);
  };

  useEffect(() => {
    const initConnection = async () => {
      if (!socket) {
        addDebugMessage('Waiting for socket connection...');
        return;
      }

      addDebugMessage('Socket initialized');

      const urlParams = new URLSearchParams(window.location.search);
      const screen = urlParams.get('screen');
      
      if (screen) {
        addDebugMessage(`Joining room: ${screen}`);
        socket.emit('join-room', screen);
        await new Promise(resolve => setTimeout(resolve, 1000));
        initializePeerConnection(screen);
      } else {
        addDebugMessage('No screen parameter found in URL');
      }
    };

    initConnection();

    return () => {
      if (peerConnection.current) {
        peerConnection.current.close();
      }
    };
  }, [socket]);

  const initializePeerConnection = (screen: string) => {
    if (!socket) return;

    addDebugMessage('Initializing peer connection');

    if (peerConnection.current) {
      peerConnection.current.close();
    }

    try {
      peerConnection.current = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
          { urls: 'stun:stun3.l.google.com:19302' },
          { urls: 'stun:stun4.l.google.com:19302' },
        ],
        iceCandidatePoolSize: 10
      });

      peerConnection.current.ontrack = (event) => {
        addDebugMessage('Received track');
        if (videoRef.current && event.streams[0]) {
          videoRef.current.srcObject = event.streams[0];
          setIsConnected(true);
        }
      };

      peerConnection.current.onicecandidate = (event) => {
        if (event.candidate) {
          addDebugMessage('Sending ICE candidate');
          socket.emit('signal', {
            type: 'candidate',
            candidate: event.candidate,
            screenName: screen
          });
        }
      };

      peerConnection.current.onconnectionstatechange = () => {
        const state = peerConnection.current?.connectionState;
        addDebugMessage(`Connection state changed to: ${state}`);
        
        if (state === 'failed' || state === 'disconnected' || state === 'closed') {
          setIsConnected(false);
          setTimeout(() => {
            if (isConnected) {
              addDebugMessage('Attempting to reconnect...');
              initializePeerConnection(screen);
            }
          }, 2000);
        }
      };

      peerConnection.current.oniceconnectionstatechange = () => {
        const state = peerConnection.current?.iceConnectionState;
        addDebugMessage(`ICE connection state: ${state}`);
        if (state === 'failed') {
          peerConnection.current?.restartIce();
        }
      };

      socket.on('signal', async (data) => {
        try {
          addDebugMessage(`Received signal: ${data.type}`);
          if (!peerConnection.current) return;

          if (data.type === 'offer') {
            await peerConnection.current.setRemoteDescription(new RTCSessionDescription(data.offer));
            const answer = await peerConnection.current.createAnswer();
            await peerConnection.current.setLocalDescription(answer);
            
            socket.emit('signal', {
              type: 'answer',
              answer,
              screenName: screen
            });
          } else if (data.type === 'candidate' && data.candidate) {
            await peerConnection.current.addIceCandidate(new RTCIceCandidate(data.candidate));
          }
        } catch (error) {
          addDebugMessage(`Error handling signal: ${error}`);
        }
      });

      socket.on('stop-screenshare', () => {
        addDebugMessage('Received stop-screenshare signal');
        if (videoRef.current) {
          videoRef.current.srcObject = null;
        }
        setIsConnected(false);
      });

    } catch (error) {
      addDebugMessage(`Error setting up peer connection: ${error}`);
      setIsConnected(false);
    }
  };

  return (
    <div className="w-full min-h-screen flex flex-col bg-black">
      <video
        ref={videoRef}
        autoPlay
        playsInline
        className={`w-full h-full object-contain ${isConnected ? 'opacity-100' : 'opacity-0'}`}
      />
      {!isConnected && (
        <div className="text-white text-2xl text-center p-4">
          Waiting for connection...
        </div>
      )}
      {/* Debug information */}
      <div className="fixed bottom-0 left-0 right-0 bg-black bg-opacity-75 text-white p-4 max-h-48 overflow-auto">
        <h3 className="font-bold mb-2">Debug Info:</h3>
        {debugInfo.map((msg, i) => (
          <div key={i} className="text-sm">{msg}</div>
        ))}
      </div>
    </div>
  );
}

================
File: src/hooks/useSocket.ts
================
"use client";

import { useEffect, useState, useCallback } from 'react';
import type { Socket } from 'socket.io-client';
import io from 'socket.io-client';

export const useSocket = (): Socket | null => {
  const [socket, setSocket] = useState<Socket | null>(null);

  const initSocket = useCallback(() => {
    if (typeof window === "undefined") return null;
    
    console.log('Initializing socket connection');
    const socketIo = io('http://localhost:3000', {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: 10,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000,
      autoConnect: false
    });

    socketIo.on('connect', () => {
      console.log('Socket connected:', socketIo.id);
      setSocket(socketIo);
    });

    socketIo.on('disconnect', (reason: string) => {
      console.log('Socket disconnected:', reason);
      if (reason === 'io server disconnect') {
        setTimeout(() => {
          socketIo.connect();
        }, 1000);
      }
    });

    socketIo.on('connect_error', (error: Error) => {
      console.error('Connection error:', error);
      if (socketIo.io.opts.transports.includes('websocket')) {
        console.log('Falling back to polling');
        socketIo.io.opts.transports = ['polling'];
      }
    });

    socketIo.connect();
    return socketIo;
  }, []);

  useEffect(() => {
    const socketIo = initSocket();
    return () => {
      console.log('Cleaning up socket connection');
      if (socketIo) {
        socketIo.disconnect();
      }
    };
  }, [initSocket]);

  return socket;
};

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

export default {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
    },
  },
  plugins: [],
} satisfies Config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
